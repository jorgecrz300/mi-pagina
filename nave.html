<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <title>CRZ Star-Hacker 3D | Lobby</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Courier New', monospace; }
        
        /* Interfaz de Usuario durante el juego */
        #ui {
            display: none; position: absolute; top: 20px; width: 100%; text-align: center;
            color: #00ffff; pointer-events: none; text-shadow: 0 0 10px #00ffff; z-index: 10;
        }
        #distancia { font-size: 35px; font-weight: bold; }

        /* Estilo del Lobby */
        #lobby {
            position: fixed; width: 100%; height: 100%; background: rgba(0,0,0,0.8);
            display: flex; flex-direction: column; align-items: center; justify-content: center;
            color: #00ffff; z-index: 200; text-align: center;
        }
        .titulo { font-size: 50px; font-weight: bold; margin-bottom: 10px; text-shadow: 0 0 20px #00ffff; }
        .subtitulo { font-size: 18px; color: #fff; margin-bottom: 30px; letter-spacing: 2px; }
        .controles { background: rgba(0, 255, 255, 0.1); padding: 20px; border-radius: 10px; border: 1px solid #00ffff; margin-bottom: 30px; }

        /* Botones */
        button {
            background: transparent; color: #00ffff; border: 2px solid #00ffff; 
            padding: 15px 40px; cursor: pointer; font-family: 'Courier New'; 
            font-weight: bold; font-size: 20px; transition: 0.3s;
        }
        button:hover { background: #00ffff; color: #000; box-shadow: 0 0 30px #00ffff; }

        #gameOver {
            display: none; position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%);
            background: rgba(0,0,0,0.9); border: 2px solid #ff3333; padding: 40px; 
            text-align: center; color: #ff3333; z-index: 100; box-shadow: 0 0 20px #ff3333;
        }
    </style>
</head>
<body>

    <div id="lobby">
        <div class="titulo">CRZ STAR-HACKER 3D</div>
        <div class="subtitulo">INTERCEPTOR RSI - PROTOCOLO ACTIVO</div>
        
        <div class="controles">
            <p>MOVER: [A][D] o FLECHAS</p>
            <p>OBJETIVO: ESQUIVAR METEOROS</p>
        </div>

        <button onclick="empezarJuego()">INICIAR MISIÓN</button>
    </div>

    <div id="ui">
        <div id="distancia">KM: 0</div>
        <div style="font-size: 10px; color: #ffffff;">PILOTO: CRZ-USER | NAV: ONLINE</div>
    </div>

    <div id="gameOver">
        <h1>CONEXIÓN PERDIDA</h1>
        <p>EL INTERCEPTOR HA SIDO DESTRUIDO</p>
        <div id="finalScore" style="margin: 10px 0; font-size: 20px;"></div>
        <button onclick="location.reload()" style="color:#ff3333; border-color:#ff3333;">RECONECTAR</button>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <script>
        let escena, camara, render, nave;
        let meteoros = [];
        let distancia = 0;
        let vivo = true;
        let jugando = false;
        let teclas = {};

        function empezarJuego() {
            jugando = true;
            document.getElementById('lobby').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
        }

        function init() {
            escena = new THREE.Scene();
            escena.background = new THREE.Color(0x050510); 
            camara = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            render = new THREE.WebGLRenderer({ antialias: true });
            render.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(render.domElement);

            // NAVE (Mismo diseño RSI plateado)
            nave = new THREE.Group();
            const matCuerpo = new THREE.MeshStandardMaterial({ color: 0xaaaaaa, metalness: 0.9, roughness: 0.1 });
            const matNeon = new THREE.MeshBasicMaterial({ color: 0x00ffff });

            const cuerpo = new THREE.Mesh(new THREE.ConeGeometry(0.5, 3, 4), matCuerpo);
            cuerpo.scale.set(1, 1, 0.5); 
            nave.add(cuerpo);

            const crearAla = (x, rotZ) => {
                const alaG = new THREE.Group();
                const p = new THREE.Mesh(new THREE.BoxGeometry(1.8, 0.8, 0.1), matCuerpo);
                p.position.set(x * 0.9, -0.5, 0); p.rotation.z = rotZ;
                const b = new THREE.Mesh(new THREE.BoxGeometry(1.9, 0.05, 0.12), matNeon);
                b.position.set(x * 0.9, -0.2, 0.05); b.rotation.z = rotZ;
                alaG.add(p); alaG.add(b); return alaG;
            };
            nave.add(crearAla(1, -Math.PI / 4));
            nave.add(crearAla(-1, Math.PI / 4));

            const crearMotor = (x) => {
                const mG = new THREE.Group();
                const m = new THREE.Mesh(new THREE.CylinderGeometry(0.18, 0.18, 0.6, 8), matCuerpo);
                const l = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.1, 8), matNeon);
                l.position.y = -0.35; mG.add(m); mG.add(l);
                mG.position.set(x, -1.2, 0); return mG;
            };
            nave.add(crearMotor(0.35));
            nave.add(crearMotor(-0.35));

            nave.rotation.x = Math.PI / 2.2;
            nave.position.y = -1;
            escena.add(nave);

            // LUCES
            const luzFrontal = new THREE.DirectionalLight(0xffffff, 1.8);
            luzFrontal.position.set(0, 5, 10); escena.add(luzFrontal);
            escena.add(new THREE.AmbientLight(0xffffff, 0.6));

            camara.position.set(0, 1.5, 5);
            
            crearEstrellas();
            animar();
        }

        function crearEstrellas() {
            for(let i=0; i<300; i++) {
                const e = new THREE.Mesh(new THREE.SphereGeometry(0.04, 4, 4), new THREE.MeshBasicMaterial({ color: 0xffffff }));
                e.position.set(Math.random()*60-30, Math.random()*60-30, Math.random()*-150);
                escena.add(e);
            }
        }

        function lanzarMeteoro() {
            if(!vivo || !jugando) return;
            const size = Math.random() * 0.8 + 0.4;
            const m = new THREE.Mesh(new THREE.IcosahedronGeometry(size, 0), new THREE.MeshPhongMaterial({ color: 0x888888, flatShading: true }));
            m.position.set(Math.random()*12-6, -1, -60);
            escena.add(m);
            meteoros.push(m);
        }

        setInterval(lanzarMeteoro, 450);

        window.onkeydown = (e) => teclas[e.key] = true;
        window.onkeyup = (e) => teclas[e.key] = false;

        function animar() {
            requestAnimationFrame(animar);

            if(jugando && vivo) {
                // Lógica de Juego
                if((teclas['ArrowLeft'] || teclas['a']) && nave.position.x > -6) {
                    nave.position.x -= 0.22;
                    nave.rotation.z = 0.5;
                } else if((teclas['ArrowRight'] || teclas['d']) && nave.position.x < 6) {
                    nave.position.x += 0.22;
                    nave.rotation.z = -0.5;
                } else {
                    nave.rotation.z = 0;
                }

                distancia += 2;
                document.getElementById('distancia').innerText = "KM: " + distancia;

                meteoros.forEach((m, index) => {
                    m.position.z += 0.7 + (distancia/5000); 
                    m.rotation.y += 0.02;

                    if(m.position.z > 3.8 && m.position.z < 5.2) {
                        let dx = Math.abs(m.position.x - nave.position.x);
                        if(dx < 1.7) { 
                            vivo = false;
                            document.getElementById('finalScore').innerText = "DISTANCIA: " + distancia + " KM";
                            document.getElementById('gameOver').style.display = 'block';
                        }
                    }
                    if(m.position.z > 10) {
                        escena.remove(m);
                        meteoros.splice(index, 1);
                    }
                });
            } else if (!jugando) {
                // Animación suave en el Lobby
                nave.rotation.y += 0.01;
                nave.position.y = -1 + Math.sin(Date.now() * 0.002) * 0.1;
            }

            render.render(escena, camara);
        }

        init();
        window.addEventListener('resize', () => {
            camara.aspect = window.innerWidth / window.innerHeight;
            camara.updateProjectionMatrix();
            render.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
